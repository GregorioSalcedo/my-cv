---
title: "Lab 02 - simulations"
author: "Gregorio Salcedo"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_document:
    df_print: paged
    theme: cerulean
    highlight: haddock
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE}
library(dplyr)
library(tidyverse)
```

### STEP 1 - CREATE A NEW GAME

This function sets up a new game.

```{r}
# step 1: create a vector of 3 doors: 2 goats and 1 car
# step 2: randomize the position of the car for a new game
# step 3: return the new game vector 

# note that no external information is needed
# so no arguments are passed to the vector 
create_game <- function() {
  a.game <- sample(c("goat", "goat", "goat", "car", "car"), size = 5, replace = FALSE)
  return(a.game)
}

# try five times to see randomization 
create_game()  
create_game() 
create_game() 
create_game()
create_game()
```

### STEP 2 - CONTESTANT SELECTS A DOOR

The contestant makes their first selection. Write a function to select one door at random.

```{r}

# step 1: create a vector of doors numbered 1,2,3
# step 2: randomly select ONE of the doors 
# step 3: return the selection 

# since the contestant will not know the position 
# of the car when they select a door we do not 
# need to share information about the game set-up
# before the selection is made 

select_door <- function() {
  sample(1:3, size = 1)
}
select_door()
```

### STEP 3 - HOST OPENS GOAT DOOR

The host will always open a door with a goat behind it. But it can’t be a door the contestant has already selected. So it must be a door that is not a car and not a current contestant selection.

```{r}


# step 1:Identify doors with goats that the contestant has not selected.
# step 2: Randomly pick one of these doors.
# step 3: Return the door number.

open_goat_door <- function(game, a.pick) {
  doors <- setdiff(1:5, a.pick)
  doors <- doors[game[doors] != "car"]
  sample(doors, size = 1)
}

this_game <- create_game()
my_pick <- select_door()
open_goat_door(this_game, my_pick)
```

### STEP 4 - CHANGE DOORS

The contestant is given the option to change from their initial selection to the other door that is still closed. The function will represent the game-playing strategy as the argument stay=TRUE or stay=FALSE.

```{r}

# If the strategy is "stay," keep the original.
# If the strategy is "switch," choose the door that is not the original or the opened goat door.
# Return the final pick.

change_door <- function(stay = TRUE, opened.door, a.pick) {
  if (stay) {
    return(a.pick)
  } else {
    return(sample(setdiff(1:3, c(a.pick, opened.door)), size = 1))
  }
}


opened_door <- open_goat_door(this_game, my_pick)
change_door(stay = TRUE, opened_door, my_pick)
change_door(stay = FALSE, opened_door, my_pick)

```

### STEP 5 - DETERMINE IF CONTENSTANT HAS WON

```{r}

# Check if the contestant’s final pick corresponds to the "car" in the game setup.
# Return "WIN" or "LOSE."


determine_winner <- function(final.pick, game) {
  if (game[final.pick] == "car") {
    return("WIN")
  } else {
    return("LOSE")
  }
}

final_pick <- change_door(stay = FALSE, opened_door, my_pick)
determine_winner(final_pick, this_game)

```

### TESTING THE GAME

```{r, echo=F}
# your game "recipe" 
this.game <- create_game()
my.initial.pick <- select_door()
opened.goat.door <- open_goat_door( this.game, my.initial.pick )

# save results for both strategies for the game
my.final.pick.stay <- change_door( stay=T, 
                                   opened.door=opened.goat.door, 
                                   a.pick=my.initial.pick )
my.final.pick.switch <- change_door( stay=F, 
                                     opened.door=opened.goat.door, 
                                     a.pick=my.initial.pick )

# Compute outcomes
game.outcome.stay <- determine_winner(final.pick = my.final.pick.stay, game = this.game)
game.outcome.switch <- determine_winner(final.pick = my.final.pick.switch, game = this.game)


# print game details and if you won

# if you stayed:
paste0( "GAME SETUP" )
this.game
paste0( "My initial selection: ", my.initial.pick )
paste0( "The opened goat door: ", opened.goat.door )
paste0( "My final selection: ", my.final.pick.stay )
paste0( "GAME OUTCOME:" )
determine_winner( final.pick=my.final.pick.stay, 
                  game=this.game )

# if you switched:
paste0( "GAME SETUP" )
this.game
paste0( "My initial selection: ", my.initial.pick )
paste0( "The opened goat door: ", opened.goat.door )
paste0( "My final selection: ", my.final.pick.switch )
paste0( "GAME OUTCOME:" )
determine_winner( final.pick=my.final.pick.switch, 
                  game=this.game )
```

### IF CONTESTANT STAYS

Game Setup: **`r paste0( toupper(this.game), collapse=" " )`**\
Initial selection: **`r my.initial.pick`**\
The opened goat door: **`r opened.goat.door`**\
Final door selection: **`r my.final.pick.stay`** Game outcome: **`r game.outcome.stay`**

```{r, echo=F}
this.game[ this.game == "car" ] <- "car "
this.game <- toupper( this.game )

first.pick <- c("        ","        ","        ")
first.pick[ my.initial.pick ] <- "1st Pick"
open.door <- c("        ","        ","        ")
open.door[ opened.goat.door ] <- " Opened "
final <- c("        ","        ","        ")
final[ my.final.pick.stay ] <- " Final  " 

win.lose <- final
win.lose[ my.final.pick.stay ] <- paste0( "! ", game.outcome.stay, " !" )

outcome <- paste0( rep( paste0( "! ", game.outcome.stay, " !" ), 5 ), collapse="" )
  
paste0( "  | ", this.game[1], " |     | ", this.game[2], " |     | ", this.game[3], " |  " )
paste0( "  ", first.pick[1], "     ", first.pick[2], "     ", first.pick[3], "  " )
paste0( "  ", open.door[1], "     ", open.door[2], "     ", open.door[3], "  " )
paste0( "  ", final[1], "     ", final[2], "     ", final[3], "  " )
paste0( "  ", win.lose[1], "     ", win.lose[2], "     ", win.lose[3], "  " )
```

### IF CONTESTANT SWITCHES

Game Setup: **`r paste0( toupper(this.game), collapse=" " )`**\
Initial selection: **`r my.initial.pick`**\
The opened goat door: **`r opened.goat.door`**\
Final door selection: **`r my.final.pick.switch`**\
Game outcome: **`r game.outcome.switch`**

```{r, echo=F}

this.game[ this.game == "car" ] <- "car "
this.game <- toupper( this.game )
first.pick <- c("        ","        ","        ")
first.pick[ my.initial.pick ] <- "1st Pick"
open.door <- c("        ","        ","        ")
open.door[ opened.goat.door ] <- " Opened "
final <- c("        ","        ","        ")
final[ my.final.pick.switch ] <- " Final  " 
outcome <- paste0( rep( paste0( " ", game.outcome.switch, "! " ), 5 ), collapse="" )

win.lose <- final
win.lose[ my.final.pick.switch ] <- paste0( "! ", game.outcome.switch, " !" )

paste0( "  | ", this.game[1], " |     | ", this.game[2], " |     | ", this.game[3], " |  " )
paste0( "  ", first.pick[1], "     ", first.pick[2], "     ", first.pick[3], "  " )
paste0( "  ", open.door[1], "     ", open.door[2], "     ", open.door[3], "  " )
paste0( "  ", final[1], "     ", final[2], "     ", final[3], "  " )
paste0( "  ", win.lose[1], "     ", win.lose[2], "     ", win.lose[3], "  " )

```

```{r play_game_test}
play_game <- function() {
  new.game <- create_game()
  first.pick <- select_door()
  opened.door <- open_goat_door(new.game, first.pick)
  
  final.pick.stay <- change_door(stay = TRUE, opened.door, first.pick)
  final.pick.switch <- change_door(stay = FALSE, opened.door, first.pick)
  
  outcome.stay <- determine_winner(final.pick.stay, new.game)
  outcome.switch <- determine_winner(final.pick.switch, new.game)
  
  strategy <- c("stay", "switch")
  outcome <- c(outcome.stay, outcome.switch)
  game.results <- data.frame(strategy, outcome, stringsAsFactors = FALSE)
  
  return(game.results)
}
```

```{r}
  play_game()
```

```{r}
results.df <- data.frame()  #empty data frame

for (i in 1:10000) {
  game.outcome <- play_game()
  results.df <- rbind(results.df, game.outcome)
}

#results
summary <- table(results.df) %>% prop.table(margin = 1) %>% round(2)
print(summary)
```

### PART 1

Q1: Is SWITCH still the dominant strategy? Support your answer with your data.

The answer is likely No, as the advantage of switching diminishes significantly in the 5-door scenario. In this variation, the staying strategy improves, favoring winning by 3% more compared to the classic 3-door game. Meanwhile, the switching strategy shifts dramatically to a near 50/50 chance of winning or losing (47% win vs. 53% lose). This suggests that the added complexity of the 5-door game and the host revealing both a goat and a car door reduces the informational advantage gained by switching, making it less dominant than in the original 3-door scenario.

### PART 2

Q2:


```{r}
#Custom Game
create_custom_game <- function(num_cars, num_goats) {
  doors <- c(rep("car", num_cars), rep("goat", num_goats))
  sample(doors)
}

create_custom_game(2, 8)
```

```{r}
play_custom_game <- function(num_cars, num_goats) {
  #custom game
  new_game <- create_custom_game(num_cars, num_goats)

  # Contestant first selection
  first_pick <- sample(1:length(new_game), 1)

  # Host opens a goat door
  goat_door <- which(new_game == "goat" & seq_along(new_game) != first_pick)[1]

  # stay or switch
  stay_pick <- first_pick
  switch_pick <- setdiff(1:length(new_game), c(first_pick, goat_door))[1]

  # outcomes
  outcome_stay <- ifelse(new_game[stay_pick] == "car", "WIN", "LOSE")
  outcome_switch <- ifelse(new_game[switch_pick] == "car", "WIN", "LOSE")

  # results
  strategy <- c("stay", "switch")
  outcome <- c(outcome_stay, outcome_switch)
  data.frame(strategy, outcome, stringsAsFactors = FALSE)
}

play_custom_game(2, 8)
```




```{r}
simulate_custom_games <- function(num_simulations, num_cars, num_goats) {
  results_df <- NULL

  for (i in 1:num_simulations) {
    game_result <- play_custom_game(num_cars, num_goats)
    results_df <- rbind(results_df, game_result)
  }

  results_df
}

# scenarios
scenario_1 <- simulate_custom_games(10000, 1, 9)  # 1 car, 9 goats
scenario_2 <- simulate_custom_games(10000, 2, 8)  # 2 cars, 8 goats
scenario_3 <- simulate_custom_games(10000, 3, 7)  # 3 cars, 7 goats

#  results
analyze_results <- function(results_df) {
  table(results_df$strategy, results_df$outcome) %>%
    prop.table(margin = 1) %>%
    round(2)
}

results_1 <- analyze_results(scenario_1)
results_2 <- analyze_results(scenario_2)
results_3 <- analyze_results(scenario_3)

print (results_1)
print (results_2)
print (results_3)
```

Q1: Is SWITCH still the dominant strategy? Report your chances of winning for each strategy for each scenario.

Yes, switching remains the dominant strategy across all scenarios, as it consistently offers a higher chance of winning than staying:
-1 car, 9 goats: Switching improves the win probability from 10% to 20%.
-2 cars, 8 goats: Switching improves the win probability from 20% to 38%.
-3 cars, 7 goats: Switching improves the win probability from 30% to 54%.

While the advantage of switching decreases as the number of cars increases, it still provides better odds than staying.

Q2: How much better off are you switching in the original game? How much did it improve your chances of winning?
In the classic 3-door Monty Hall problem, the probabilities are:
Stay: 33% win, 67% lose
Switch: 67% win, 33% lose

67%−33%=34%
Switching offers a 34% improvement in the original game.

𝑃𝑟(𝑤𝑖𝑛|𝑠𝑤𝑖𝑡𝑐ℎ)−𝑃𝑟(𝑤𝑖𝑛|𝑠𝑡𝑎𝑦)
Q3: How much better off are you switching in each of the three scenario with 10 doors and 1 to 3 cars?
1 car: 20%−10%=10%
2 car: 38%−20%=18%
3 car: 54%−30%=24%